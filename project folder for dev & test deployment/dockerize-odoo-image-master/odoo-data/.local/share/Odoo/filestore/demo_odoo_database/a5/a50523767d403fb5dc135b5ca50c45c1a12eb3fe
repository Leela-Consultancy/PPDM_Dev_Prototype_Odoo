)]}'
{"version": 3, "sources": ["/web/static/src/legacy/js/public/lazyloader.js", "/web_editor/static/src/js/frontend/loader_loading.js", "/website/static/src/js/content/inject_dom.js", "/website/static/src/js/content/auto_hide_menu.js", "/website/static/src/js/content/adapt_content.js"], "mappings": "AAAA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnHA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5CA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjCA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["odoo.define('web.public.lazyloader', function (require) {\n'use strict';\n\nvar blockEvents = ['submit', 'click'];\nvar blockFunction = function (ev) {\n    ev.preventDefault();\n    ev.stopImmediatePropagation();\n};\n\nvar waitingLazy = false;\n\n/**\n * Blocks the DOM sections which explicitly require the lazy loaded JS to be\n * working (those sections should be marked with the 'o_wait_lazy_js' class).\n *\n * @see stopWaitingLazy\n */\nfunction waitLazy() {\n    if (waitingLazy) {\n        return;\n    }\n    waitingLazy = true;\n\n    var lazyEls = document.querySelectorAll('.o_wait_lazy_js');\n    for (var i = 0; i < lazyEls.length; i++) {\n        var element = lazyEls[i];\n        blockEvents.forEach(function (evType) {\n            element.addEventListener(evType, blockFunction);\n        });\n    }\n\n    document.body.classList.add('o_lazy_js_waiting');\n}\n/**\n * Unblocks the DOM sections blocked by @see waitLazy and removes the related\n * 'o_wait_lazy_js' class from the whole DOM.\n */\nfunction stopWaitingLazy() {\n    if (!waitingLazy) {\n        return;\n    }\n    waitingLazy = false;\n\n    var lazyEls = document.querySelectorAll('.o_wait_lazy_js');\n    for (var i = 0; i < lazyEls.length; i++) {\n        var element = lazyEls[i];\n        blockEvents.forEach(function (evType) {\n            element.removeEventListener(evType, blockFunction);\n        });\n        element.classList.remove('o_wait_lazy_js');\n    }\n\n    document.body.classList.remove('o_lazy_js_waiting');\n}\n\n// Start waiting for lazy loading as soon as the DOM is available\nif (document.readyState !== 'loading') {\n    waitLazy();\n} else {\n    document.addEventListener('DOMContentLoaded', function () {\n        waitLazy();\n    });\n}\n\n// As soon as everything is fully loaded, start loading all the remaining JS\n// and unblock the related DOM section when all of it have been loaded and\n// executed\nvar doResolve = null;\nvar _allScriptsLoaded = new Promise(function (resolve) {\n    if (doResolve) {\n        resolve();\n    } else {\n        doResolve = resolve;\n    }\n}).then(function () {\n    stopWaitingLazy();\n});\nif (document.readyState === 'complete') {\n    setTimeout(_loadScripts, 0);\n} else {\n    window.addEventListener('load', function () {\n        setTimeout(_loadScripts, 0);\n    });\n}\n\n/**\n * @param {DOMElement[]} scripts\n * @param {integer} index\n */\nfunction _loadScripts(scripts, index) {\n    if (scripts === undefined) {\n        scripts = document.querySelectorAll('script[data-src]');\n    }\n    if (index === undefined) {\n        index = 0;\n    }\n    if (index >= scripts.length) {\n        if (typeof doResolve === 'function') {\n            doResolve();\n        } else {\n            doResolve = true;\n        }\n        return;\n    }\n    var script = scripts[index];\n    script.addEventListener('load', _loadScripts.bind(this, scripts, index + 1));\n    script.src = script.dataset.src;\n    script.removeAttribute('data-src');\n}\n\nreturn {\n    loadScripts: _loadScripts,\n    allScriptsLoaded: _allScriptsLoaded,\n};\n});\n", "(function () {\n'use strict';\n\n/**\n * This file makes sure textarea elements with a specific editor class are\n * tweaked as soon as the DOM is ready so that they appear to be loading.\n *\n * They must then be loaded using standard Odoo modules system. In particular,\n * @see web_editor.loader\n */\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Standard loop for better browser support\n    var textareaEls = document.querySelectorAll('textarea.o_wysiwyg_loader');\n    for (var i = 0; i < textareaEls.length; i++) {\n        var textarea = textareaEls[i];\n        var wrapper = document.createElement('div');\n        wrapper.classList.add('position-relative', 'o_wysiwyg_textarea_wrapper');\n\n        var loadingElement = document.createElement('div');\n        loadingElement.classList.add('o_wysiwyg_loading');\n        var loadingIcon = document.createElement('i');\n        loadingIcon.classList.add('text-600', 'text-center',\n            'fa', 'fa-circle-o-notch', 'fa-spin', 'fa-2x');\n        loadingElement.appendChild(loadingIcon);\n        wrapper.appendChild(loadingElement);\n\n        textarea.parentNode.insertBefore(wrapper, textarea);\n        wrapper.insertBefore(textarea, loadingElement);\n    }\n});\n\n})();\n", "/** @odoo-module */\n\nimport { get_cookie } from 'web.utils.cookies';\nimport { session } from '@web/session';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Transfer cookie/session data as HTML element's attributes so that CSS\n    // selectors can be based on them.\n    const htmlEl = document.documentElement;\n    const cookieNamesToDataNames = {\n        'utm_source': 'utmSource',\n        'utm_medium': 'utmMedium',\n        'utm_campaign': 'utmCampaign',\n    };\n    for (const [name, dsName] of Object.entries(cookieNamesToDataNames)) {\n        const cookie = get_cookie(`odoo_${name}`);\n        if (cookie) {\n            // Remove leading and trailing \" and '\n            htmlEl.dataset[dsName] = cookie.replace(/(^[\"']|[\"']$)/g, '');\n        }\n    }\n    const country = session.geoip_country_code;\n    if (country) {\n        htmlEl.dataset.country = country;\n    }\n\n    htmlEl.dataset.logged = !session.is_website_user;\n\n    // Create CSS rules in a dedicated style tag according to the snippet\n    // visibility option's computed ones (saved as data attributes).\n    const styleEl = document.createElement('style');\n    styleEl.id = \"conditional_visibility\";\n    document.head.appendChild(styleEl);\n    const conditionalEls = document.querySelectorAll('[data-visibility=\"conditional\"]');\n    for (const conditionalEl of conditionalEls) {\n        const selectors = conditionalEl.dataset.visibilitySelectors;\n        styleEl.sheet.insertRule(`${selectors} { display: none !important; }`);\n    }\n\n    // Now remove the classes that makes them always invisible\n    for (const conditionalEl of conditionalEls) {\n        conditionalEl.classList.remove('o_conditional_hidden');\n    }\n});\n", "/** @odoo-module **/\n\nimport { initAutoMoreMenu } from '@web/legacy/js/core/menu';\n\n/**\n * Auto adapt the header layout so that elements are not wrapped on a new line.\n */\ndocument.addEventListener('DOMContentLoaded', async () => {\n    const header = document.querySelector('header#top');\n    if (header) {\n        const topMenu = header.querySelector('#top_menu');\n        if (header.classList.contains('o_no_autohide_menu')) {\n            topMenu.classList.remove('o_menu_loading');\n            return;\n        }\n        const unfoldable = '.divider, .divider ~ li, .o_no_autohide_item, .js_language_selector';\n        const excludedImagesSelector = '.o_mega_menu, .o_offcanvas_logo_container, .o_lang_flag';\n        const excludedImages = [...header.querySelectorAll(excludedImagesSelector)];\n        const images = [...header.querySelectorAll('img')].filter((img) => {\n            excludedImages.forEach(node => {\n                if (node.contains(img)) {\n                    return false;\n                }\n            });\n            return img.matches && !img.matches(excludedImagesSelector);\n        });\n        initAutoMoreMenu(topMenu, {\n            unfoldable: unfoldable,\n            images: images,\n            loadingStyleClasses: ['o_menu_loading']\n        });\n    }\n});\n", "/** @odoo-module */\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const htmlEl = document.documentElement;\n    const editTranslations = !!htmlEl.dataset.edit_translations;\n    // Hack: on translation editor, textareas with translatable text content\n    // will get a `<span/>` as translation value which stays visible until\n    // the values are updated on the editor. The same issue was fixed on CSS\n    // for `placeholder` and `value` attributes (since we can get the elements\n    // with attribute translation on CSS). But here, we need to hide the text\n    // on JS until the editor's code sets the right values on textareas.\n    if (editTranslations) {\n        [...document.querySelectorAll('textarea')].map(textarea => {\n            if (textarea.value.indexOf('data-oe-translation-id') !== -1) {\n                textarea.classList.add('o_text_content_invisible');\n            }\n        });\n    }\n});\n"], "file": "/web/assets/241-bda3c34/1/web.assets_frontend_minimal.js", "sourceRoot": "../../../../"}